{
  "paper": {
    "paper_id": "arxiv:1904.03816v1",
    "title": "Towards Real-Time Automatic Portrait Matting on Mobile Devices",
    "authors": [
      "Seokjun Seo",
      "Seungwoo Choi",
      "Martin Kersner",
      "Beomjun Shin",
      "Hyungsuk Yoon",
      "Hyeongmin Byun",
      "Sungjoo Ha"
    ],
    "year": 2019,
    "venue": "arXiv",
    "source": "arxiv",
    "abstract": "We tackle the problem of automatic portrait matting on mobile devices. The proposed model is aimed at attaining real-time inference on mobile devices with minimal degradation of model performance. Our model MMNet, based on multi-branch dilated convolution with linear bottleneck blocks, outperforms the state-of-the-art model and is orders of magnitude faster. The model can be accelerated four times to attain 30 FPS on Xiaomi Mi 5 device with moderate increase in the gradient error. Under the same conditions, our model has an order of magnitude less number of parameters and is faster than Mobile DeepLabv3 while maintaining comparable performance. The accompanied implementation can be found at \\url{https://github.com/hyperconnect/MMNet}.",
    "pdf_path": "data/automation/papers/arxiv_1904.03816v1.pdf",
    "url": "https://arxiv.org/pdf/1904.03816v1",
    "doi": null,
    "arxiv_id": "1904.03816v1",
    "openalex_id": null,
    "citation_count": 0,
    "is_open_access": true,
    "sync_timestamp": "2026-02-20 17:55:18.075415+00:00"
  },
  "snippets": [
    {
      "snippet_id": "Parxiv_1904_03816v1:S1",
      "paper_id": "arxiv:1904.03816v1",
      "section": "body",
      "text": "Towards Real-Time Automatic Portrait Matting on Mobile Devices Seokjun Seo\u22171, Seungwoo Choi \u22171, Martin Kersner \u22171, Beomjun Shin \u22171, Hyungsuk Yoon \u20202, Hyeongmin Byun 1, and Sungjoo Ha 1 1Hyperconnect, Seoul, South Korea 2Unaf\ufb01liated, Seoul, South Korea {seokjun.seo, seungwoo.choi, martin.kersner}@hpcnt.com youhanmir@gmail.com {hyeongmin.byun, shurain}hpcnt.com",
      "page_hint": null,
      "token_count": 43,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S2",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "We tackle the problem of automatic portrait matting on mobile devices. The proposed model is aimed at attaining real-time inference on mobile devices with minimal degra- dation of model performance. Our model MMNet, based on multi-branch dilated convolution with linear bottleneck blocks, outperforms the state-of-the-art model and is or- ders of magnitude faster. The model can be accelerated four times to attain 30 FPS on Xiaomi Mi 5 device with moderate increase in the gradient error. Under the same conditions, our model has an order of magnitude less num- ber of parameters and is faster than Mobile DeepLabv3 while maintaining comparable performance. The accompa- nied implementation can be found athttps://github. com/hyperconnect/MMNet. 1. Introduction Image matting, the task which predicts alpha",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S3",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "values of foreground on every pixel, has been studied [8, 12\u201315]. Im- age matting system offers an opportunity for wide applica- tions in computer vision such as color transformation, styl- ization, and background edits. It is well-known, however, that image matting is an ill-posed problem [19] since seven unknown values (three for foreground RGB, three for back- ground RGB and one for alpha) should be inferred from three known RGB values. The most widely used method to alleviate the dif\ufb01culties of the matting problem is to utilize an additional input which roughly separates an im- age such as trimap [12, 30] and scribbles [19]. A trimap \u2217Equal contributions. \u2020Work done while at Hyperconnect. 7.3 7.4 7.5 DAPM LDN+FB MD8 MD16",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S4",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "MMNet 32 38 44 53 61 66 82 90 113 129 140146 Latency (ms), Xiaomi Mi 5 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 Grad Error (\u00d710\u22123) 0.35* 1.0* ~ 0.50.5 ~ 1.4* 0.75* 0.75* ~ 1.0* 1.0 0.5* 0.75 0.75 ~ Figure 1. The trade-off between gradient error and latency on a mobile device. Latency is measured using a Qualcomm Snap- dragon 820 MSM8996 CPU. Size of each circle is proportional to the logarithm of the number of parameters used by the model. Different circles of Mobile DeepLabv3 are created by varying the output stride and width multiplier. The circles are marked with their width multiplier. Results using 128 \u00d7128 inputs are marked with \u2217, otherwise, inputs are",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S5",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "in 256 \u00d7256. Notice that MMNet outperforms all other models forming a Pareto front. The number of parameters for LDN+FB is not reported in their paper. Best viewed in color. splits an image into three parts: de\ufb01nite foreground, def- inite background, and ambiguous blended regions. Scrib- bles, on the other hand, indicate foreground and background with a few strokes. Even though some of the traditional methods [19, 27, 30, 34] work well if additional inputs are provided, it is hard to extend these methods to various im- age and video matting applications which require real-time performance due to their high computational complexity as well as the dependency on user-interactive inputs. Other approaches have been studied to automate matting 1 arXiv:1904.03816v1",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S6",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "[cs.CV] 8 Apr 2019 Convolution Encoder Decoder Enhancement Refinement Figure 2. The overall structure of the proposed model. A standard encoder-decoder architecture is adopted. Successively applying encoder blocks summarize spatial information and capture higher semantic information. Decoding phase upsamples the image with decoder blocks and improves the result with enhancement blocks. Information from skip connections is concatenated with the upsampled information. Images are resized to target size before going through the network. The resulting alpha matte is converted back to its original resolution. by specifying the object which has to be selected as a fore- ground [9, 29, 36], for example, portrait matting. Automatic portrait matting showed even better result than the other methods using trimap [29], but the latency",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S7",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "is far too high to be used in a real-time application. Zhu et al. [39] released a lightweight model which can perform automatic matting relatively fast on mobile devices, attaining the latency of 62 ms per image on Xiaomi Mi 5. However, the gradient error of lightweight model was more than two times worse than that of the state-of-the-art, which made it less attractive in real-world applications. In this paper, we propose a compact neural network model for automatic portrait matting which is fast enough to run on mobile devices. The proposed model adopts an encoder-decoder network structure [4] and focuses on devising ef\ufb01cient components of the network. We apply depthwise convolution [31] as the basic convolution oper- ation to",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S8",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "extract and downsample features. The depthwise convolution is considerably cheaper than other convolutions even if we take ef\ufb01cient convolutions such as1\u00d71 convolu- tion [16] into account as well. The linear bottleneck struc- ture [26] bene\ufb01ts from the ef\ufb01ciency of depthwise convo- lutions, boosting the performance while maintaining the la- tency. Building upon these observations, the encoder block of the proposed model, consists of multi-branch dilated con- volution with linear bottleneck blocks which can reduce the model size with the linear bottleneck structure while aggregating multi-scale information with multi-branch di- lated convolutions. We introduce the width multiplier, a global variable which enlarges or shrinks the number of channels of a convolution, to control the trade-off between the size and the latency",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S9",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "of the model. We incorporate mul- tiple losses into our loss function, including a gradient loss which we propose. The proposed model shows better performance than the state-of-the-art method while achieving 30 FPS on iPhone 8 without GPU acceleration. We also evaluate the trade- offs between performance, the latency on mobile devices, and the size of the model. Our model can achieve 30 FPS on Google Pixel 1 and Xiaomi Mi 5 using a single core while suffering roughly 10% degradation of gradient error compared to the state-of-the-art. Our contributions are as follows: \u2022We propose a compact network architecture for auto- matic portrait matting task which achieves a real-time latency on mobile devices. \u2022We explore multiple combinations of input resolution",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S10",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "and width multiplier, which can beat strong baselines for automatic portrait matting on mobile devices. \u2022We demonstrate the capability of each component of the model, including the multi-branch dilated convolu- tion with linear bottleneck blocks, the skip connection re\ufb01nement block and the enhancement block, through ablation studies. 2. Methods Image matting problems take input image I, which is a mixture of the foreground image F and the background image B. Each pixel at the i-th position is computed as follows: Ii = \u03b1iFi + (1\u2212\u03b1i)Bi, (1) where the foreground opacity determines \u03b1i. Since all the quantities on the right-hand side of the Equation 1 are un- known, the problem is ill-posed. However, we add an assumption thatFi and Bi are",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S11",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "iden- tical to Ii in order to reduce the complexity of the problem. Even though the assumption may decrease the performance substantially, the empirical result of our experiments show this assumption is reasonable considering the latency gain we get. 2.1. Model Architecture Our model follows a standard encoder-decoder architec- ture that is widely used in semantic segmentation tasks [4, 20, 24]. Encoder successively reduces the size of the input by downsampling and summarizes the spatial information while capturing higher semantic information. Decoder, in turn, upsamples the image to recover the detailed spatial in- formation and restores the original input resolution. The whole network structure of our model, mobile matting net- work (MMNet), is depicted in Figure 2. Many modern neural",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S12",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "network architectures replace a regular convolution with a combination of several cheaper convolutions [11, 32, 35]. Depthwise separable convolu- tion [11, 16] is one of the examples which consists of a depthwise convolution, applying a single convolutional \ufb01l- ter per input channel, and a pointwise convolution ( 1 \u00d71 convolution) that accumulates the results. We not only use depthwise separable convolution for some blocks but also adopt the concept of depthwise separable convolution when designing our encoder block. Depthwise convolution is one such example which we use extensively. All convolu- tion operations are followed by a batch normalization and a ReLU6 non-linearity except the linear projection operation that is placed at the end of the encoder block [26]. Due to",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S13",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "the linear bottleneck structure, the information \ufb02ow from an encoder block to another is projected to a low-dimensional representation. In the encoder block, the information \ufb02owing from the lower layers is expanded by the \ufb01rst1\u00d71 multi-branch con- volutions. The linear bottleneck compresses the processed image. The data upsampled by the decoder block is con- catenated with the re\ufb01ned knowledge through a skip con- nection. The number of channels for each path are main- tained to have the same value. Table 1 details how much each component expands and compresses the information \ufb02ow. To control the trade-off between model size and model performance, we adopt width multiplier [16]. The width multiplier \u03b1, is a global hyperparameter that is multiplied to the",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S14",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "number of input and output channels to make the layers thinner or thicker depending on the computational budget. 1x1 Conv 3x3 DW Conv, Stride 2 1x1 Conv / Linear 3x3 DW Conv, Stride 2 1x1 Conv 3x3 DW Conv, Stride 2 3x3 DW Conv, Dilation 23x3 DW Conv, Dilation 1 3x3 DW Conv, Dilation 2n-1 Concat 1x1 Conv \u2026 Figure 3. The encoder block. It employs a multi-branched dilated convolution with a linear bottleneck. The linear bottleneck com- presses the information to a low-dimensional representation before handing it over to the next encoder block. Name Component Details Output Size Initial Block Conv 3 \u00d73, S2 128 \u00d7128, 32 Encoder 1 DR [1,2,4,8], S2 64 \u00d764, 16 Encoder 2 DR [1,2,4,8],",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S15",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "S1 64 \u00d764, 24 Encoder 3 DR [1,2,4,8], S1 64 \u00d764, 24 Encoder 4 DR [1,2,4,8], S1 64 \u00d764, 24 Encoder 5 DR [1,2,4], S2 32 \u00d732, 40 Encoder 6 DR [1,2,4], S1 32 \u00d732, 40 Encoder 7 DR [1,2,4], S1 32 \u00d732, 40 Encoder 8 DR [1,2,4], S1 32 \u00d732, 40 Encoder 9 DR [1,2], S2 16 \u00d716, 80 Encoder 10 DR [1,2], S1 16 \u00d716, 80 Decoder 1 Upsample \u00d72 (Skip 5) 32 \u00d732, 128 Decoder 2 Upsample \u00d72 (Skip 1) 64 \u00d764, 80 Enhancement 1 DR [1,2,4], S1 64 \u00d764, 40 Enhancement 2 DR [1,2,4], S1 64 \u00d764, 40 Decoder 3 Upsample \u00d74 256 \u00d7256, 16 Final Block Conv 1 \u00d71, Softmax 256 \u00d7256, 2 Table 1.",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S16",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "The model architecture of MMNet. We assume that width multiplier are set to 1.0. Decoder #1 and #2 are connected to en- coder #5 and #1 with a skip connection and a re\ufb01nement block, respectively. DR denotes the dilation rates in the multi-branch dilated convolutions. S represents the stride value in the strided convolution. 2.1.1 Encoder Block MMNet encoder block has a multi-branched dilated con- volution structure with a linear bottleneck. Input \ufb02ows to multiple branches which undergo channel expansion fol- lowed by a strided convolution and a dilated convolution. The dilation rates are different for all branches following 2n\u22121 rates. Multi-branch dilated convolution amounts to sampling spatial information at different scales. The out- puts of different branches are concatenated",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S17",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "to form a ten- sor containing multi-scale information. Applying encoder blocks in succession allows the network to capture multi- level information increasingly. As the encoder blocks are consecutively applied, we decrease the number of branches in an encoder block, slowly changing the dilation rates from [1,2,4,8] to [1,2]. A linear bottleneck structure is imposed on the encoder block where the output of the encoder block is thinner than the intermediate representations. The \ufb01nal convolution after combining the multi-branch information projects the input to a low-dimensional compressed representation. The linear bottleneck is a decomposition of a regular convolution that connects two encoder blocks into two cheaper convolutions with reduced channels. The encoder block is illustrated in Figure 3. Resize Bilinear x2",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S18",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "(Repeatable) 1x1 Conv 3x3 DW Conv 1x1 Conv (a) Decoder Block (b) Refinement Block Figure 4. The decoder block (a) upsamples bilinearly which could be repeated multiple times to upsample by a larger factor. The re\ufb01nement block (b) is added to each skip connection where the direct information from a lower level is re\ufb01ned before merging with the higher level information from a decoder block. 2.1.2 Decoder Block The decoder performs multiple upsampling to restore the initial resolution of the input image. To help decoder with the restoration of low-level features from compressed spa- tial information, skip connections are employed to directly connect the output of the lower-layer encoder to its corre- sponding decoder [24]. Instead of using the information",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S19",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "provided by the corresponding encoder blocks without any modi\ufb01cations we re\ufb01ne the information by performing a 3 \u00d73 depthwise separable convolution. The resulting re- \ufb01ned information is concatenated with the upsampled infor- mation. This speci\ufb01c re\ufb01nement technique is reminiscent of the re\ufb01nement module proposed in SharpMask [22, 33]. A decoder block with a re\ufb01nement block is illustrated in Figure 4. In this work, we connect the feature map of en- coder #1 and encoder #5 to decoder #2 and decoder #1, re- spectively. In the \ufb01nal decoder block, we perform 4\u00d7up- sampling instead of the usual 2\u00d7to shorten the decoding pipeline. 2.1.3 Enhancement Block As the decoder block keeps upsampling the feature map, there is no way to enhance the",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S20",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "predictions of neighboring values. To tackle this problem, we insert two enhance- ment blocks in the middle of the decoding phase. Rather than designing a new block, we share the same architecture with encoder block. The only difference between enhance- ment block and encoder block is that depthwise convolution with stride two is removed because the enhancement block should sustain the resolution of a feature map. In the ab- lation study, we show the effectiveness of the enhancement block. 2.2. Loss Functions The alpha loss and the compositional loss are frequently used in matting tasks. The alpha loss L\u03b1, measures the mean absolute difference between the ground truth mask and the mask predicted by the model. The compositional loss Lc,",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S21",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "measures the mean absolute difference between the values of ground truth RGB foreground pixels and the model predicted RGB foreground pixels. The composi- tional loss penalizes the model when the model incorrectly predicts a pixel with high value. L\u03b1 = 1 K K\u2211 i=1 \u23d0\u23d0\u03b1i \u2212\u03b1gt i \u23d0\u23d0 (2) Lc = 1 3K K\u2211 i=1 3\u2211 j=1 \u23d0\u23d0\u03b1ijIij \u2212\u03b1gt ijIij \u23d0\u23d0, (3) where the K is equal to the width time height, W \u00d7H, and \u03b1is a vectorized alpha matte where each pixel value is indexed by subscript i. The gt superscript denotes the alpha matte is from ground truth. We use the KL divergence between the ground truth Agt \u2208RW\u00d7H and the model predicted A \u2208RW\u00d7H. The KL divergence",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S22",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "is de\ufb01ned to be: LKL = \u2212p(Agt) log p(A) p(Agt) (4) = \u2212p(Agt) logp(A) +p(Agt) logp(Agt). (5) The second term is the entropy of the ground truth alpha matte, which is constant with respect to model predicted A. Removing the second term leads to optimization of the following loss: \u02dcLKL = K\u2211 i=1 ( \u03b1gt i log \u03b1i + (1\u2212\u03b1gt i ) log(1\u2212\u03b1i) ) . (6) Two additional loss terms are included in the loss func- tion. An auxiliary loss [31] Laux, helps with the gradient \ufb02ow by including an additional KL divergence loss between the downsampled ground truth mask and the output of the encoder block #10. A gradient loss Lgrad, guides the model to capture \ufb01ne-grained details in",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S23",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "the edges. We use Sobel- like \ufb01lter S : S = \uf8ee \uf8f0 \u22121 8 0 1 8 \u22122 8 0 2 8 \u22121 8 0 1 8 \uf8f9 \uf8fb, (7) to create a concatenation of two image derivatives G(A) = [S \u2217A,ST \u2217A] where \u2217is a convolution. The resulting G(\u00b7) yields a two-channel output that contains the gradi- ent information along x-axis and y-axis. We apply G(\u00b7) to both the ground truth mask and the model predicted mask to compute the mean absolute differences. The gradient loss is computed as follows: Lgrad = 1 K K\u2211 i=1 \u23d0\u23d0G(A)i \u2212G(Agt)i \u23d0\u23d0 (8) = 1 2K K\u2211 i=1 (\u23d0\u23d0(S \u2217A\u2212S \u2217Agt)i \u23d0\u23d0 + \u23d0\u23d0(ST \u2217A\u2212ST \u2217Agt)i \u23d0\u23d0) . (9) The following",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S24",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "Equation 10 depicts the loss function of our proposed network. L= \u03b21L\u03b1 + \u03b22Lc + \u03b23 \u02dcLKL + \u03b24Lgrad + \u03b25Laux, (10) where we set \u03b2 values to control the in\ufb02uence of each loss terms. We set them to have equal values of one for the fol- lowing experiments. 3. Experiments Automatic portrait matting takes input image with a por- trait and denotes each pixel with a linear mixture of the fore- ground and the background. We use data provided by Shen et al. [29] which consists of 2,000 images of 600 \u00d7800 resolution where 1,700 and 300 images are split as training and testing set respectively. To overcome the lack of training data, we augment images by utilizing scaling,",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S25",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "rotation and left-right \ufb02ip. First, an image is rescaled to the input size of the model and random scaling factor is selected from 1 to 1.15. The image is then scaled with the selected factor. Rotation by [\u221215\u25e6, 15\u25e6] is applied with a probability of 0.5 which means that half of the augmented images are not rotated. Additional cropping is computed to make the size of the image to match the input size of the model. Finally, the left-right \ufb02ip is also applied with a probability of 0.5. To train our model, we optimize our proposed model with respect to the loss function in Equation 10 using Adam optimizer with a batch size of 32 and a \ufb01xed learning rate",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S26",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "of 1 \u00d710\u22124. Input images were resized to 128 \u00d7128 and 256\u00d7256. The model trained on128\u00d7128 images are faster but produces worse alpha mattes compared to the model trained on 256 \u00d7256 images. Weight decays were set to 4 \u00d710\u22127. All experiments are conducted using a Tensor- Flow [3] trained on a single Titan V GPU. Following the work of Zhu et al. [39], we used gradient error to evaluate our model in portrait matting problem. The gradient error as a metric, which is different from gradient loss, is de\ufb01ned as: 1 K \u2211 i \ued79\ued79\u2207\u03b1i \u2212\u2207\u03b1gt i \ued79\ued79, (11) where \u03b1is the alpha matte predicted by the model, and \u03b1gt is the corresponding ground truth and K is equal",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S27",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "to width \u00d7height. \u2207denotes the differential operator that is com- puted by convolving the alpha map with \ufb01rst-order Gaus- sian derivative \ufb01lters with variance 1.4 [23]. Another metric we use to evaluate our model is the mean absolute differences (MAD). The MAD is de\ufb01ned as fol- lows: 1 K \u2211 i \u23d0\u23d0\u03b1i \u2212\u03b1gt i \u23d0\u23d0. (12) For a fair comparison with previous methods, we scale the predicted alpha matte to the original size of input im- ages, 600 \u00d7800 in this case, and calculate evaluation met- rics. We compare our model to DAPM [29], LDN+FB[39], and Mobile DeepLabv3 [26]. Mobile DeepLabv3 exploits MobileNetV2 as its feature extractor and has its atrous spa- tial pyramid pooling (ASPP) module removed as suggested",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S28",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "by Sandler et al. [26]. We use Equation 10 to optimize Mo- bile DeepLabv3 in equal footings as MMNet, but remove the auxiliary loss since it requires a modi\ufb01cation to the net- work architecture. 4. Results 4.1. Matting Performance Table 2 compares the result of DAPM [29], LDN+FB [39], Mobile DeepLabv3 [26], and the pro- posed method. Input images were scaled to 128 \u00d7128 or 256 \u00d7256, depending on the hyper-parameter. When smaller images are fed into the network, the latency drops considerably at the expense of the quality of the alpha matte. Input images were rescaled back to their original resolutions before evaluation. The gradient error and the latency for DAPM and LDN+FB were reported by Zhu et al.",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S29",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "[39]. For a fair comparison, we compute the latency of the models on a Xiaomi Mi 5 device (Qualcomm Snapdragon 820 MSM8996 CPU), as suggested by Zhu et al. [39]. Since Zhu et al. [39] did not report how much CPU resources they used, we measure the latency by restricting the use to a single core. Speci\ufb01cally, we use TensorFlow Lite [2] benchmark tool to compute the latency of Mobile DeepLabv3 and MMNet by averaging 100 runs of the model inference on a Xiaomi Mi 5 device while restricting the models to use a single thread. Zhu et al. [39] reports that DAPM takes 6 seconds on a computer with Core E5-2600 @2.60Ghz CPU. MMNet- 1.0 outperforms DAPM while running",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S30",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "orders of magnitude faster on a mobile CPU. When the input image is resized to 128 \u00d7128 for faster inference, our model attains real- time inference, surpassing the rate of 30 frames per second. The real-time version of MMNet is still competitive against DAPM with a moderate increase in its gradient error. (a) Input Image (b) Ground Truth (c) Graph Cut (d) MD16-0.75 (e) MMNet-1.00 (f) MMNet-1.00* Figure 5. Visual comparison of different models. Graph Cut [25] results were obtained using OpenCV library [1]. The column marked with \u2217displays the result using 128 inputs. MMNet is better able to construct delicate details compared to other models. Note that MMNet with 128 \u00d7128 input still outputs a reasonable alpha matte despite",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S31",
      "paper_id": "arxiv:1904.03816v1",
      "section": "abstract",
      "text": "its reduced capacity. The visual comparison of alpha matte in Figure 5 illus- trates the qualitative differences of different models. MM- Net is better able to construct the \ufb01ner details compared to other models. Even the real-time version of MMNet pro- duces a reasonable alpha matte regardless of its reduced ca- pacity.",
      "page_hint": null,
      "token_count": 52,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S32",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "(ms) ( \u00d710\u22123) Graph-cut trimap\u2020 - 4.93 Trimap by [28]\u2020 - 4.61 Trimap by FCN [20]\u2020 - 4.14 Trimap by DeepLab [6]\u2020 - 3.91 Trimap by CRFasRNN [38]\u2020 - 3.56 DAPM [29] - 3.03 LDN+FB [39] 140 7.40 MD16-0.75 146 3.23 MD16-1.0 203 3.22 MD16-0.75\u2217 38 3.71 MMNet-1.0 129 2.93 MMNet-1.4 213 2.86 MMNet-1.0\u2217 32 3.38 Table 2. Model comparisons on the test split. Time is computed on Xiaomi Mi 5 phone. Mobile DeepLabv3 used output stride of 16. Floating point numbers in the method name indicate the width multiplier. The row marked with \u2217displays the result using 128 inputs. Our model outperforms other models while processing images at a faster rate. The experiments marked with \u2020are copied from Shen",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S33",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "et al. [29]. 4.2. Real-Time Inference on Mobile Devices To examine the trade-off between execution time and model performance, we explore the model space by vary- ing the width multiplier values and the input resolution. We compare our model with Mobile DeepLabv3 suggested by Sandler et al. [26]. Table 3 details the result of the experi- ment. The results are sorted by the latency and models with comparable execution time are clustered using horizontal dividers. We see that our proposed model dominates Mo- bile DeepLabv3 in all clusters in terms of gradient error. Also, note that the number of parameters differs by an or- der of magnitude. Requiring a small number of parameters is especially appealing if we target a",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S34",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "mobile device since end-users do not have to download a bulky model whenever there is an update of the model. Figure 1 plots trade-off between gradient error and la- tency on a mobile device. Note that MMNet develops a Pareto-front in this space and outperforms other models. Latency comparison of Pixel 1 and iPhone 8 are included in the supplementary material. 4.3. Ablation Studies Our proposed network owes its performance to several building blocks utilized in its model architecture. We ana- lyze the impact of each design choices by performing abla- tion experiments.",
      "page_hint": null,
      "token_count": 93,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S35",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "(ms) (10\u22123) (10 \u22122) (M) MD16-0.75 146 3.25 2.31 1.327 MMNet-1.00 129 2.93 2.48 0.199 MD8-0.75\u2217 113 3.53 2.61 1.327 MMNet-0.75 90 2.99 2.65 0.127 MD16-0.50 82 3.36 2.53 0.454 MD8-0.50\u2217 66 3.61 2.85 0.713 MMNet-0.50 61 3.17 2.83 0.069 MMNet-1.40\u2217 55 3.38 2.72 0.369 MD16-1.00\u2217 53 3.68 2.88 2.142 MD8-0.35\u2217 44 3.72 3.07 0.454 MD16-0.75\u2217 38 3.77 2.96 1.327 MMNet-1.00\u2217 32 3.44 2.97 0.199 MMNet-1.00Q 98 2.88 2.47 0.199 Table 3. Comparison of MMNet against Mobile DeepLabv3. Floating point numbers in the method name indicate the width multiplier. The row marked with \u2217displays the result using 128 inputs. Output strides of 8 and 16 were tested for Mobile DeepLabv3. Note that the proposed model dominates Mobile DeepLabv3 when the",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S36",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "latency is less than 60. In slower regime, MMNet still outperforms Mobile DeepLabv3 in gradient error but are sometimes worse in MAD. Quantized model is included in the last row. 4.3.1 Network Component Dilation Rates in Encoder Block We study the effect of different dilation rates in the encoder block. The proposed model contains a multi-branch dilated convolutions in the encoder block. We analyze the impact of this decision by \ufb01xing the dilation rates to one. Re\ufb01nement Block Whenever there is a skip connection, we have included a re\ufb01nement block to improve the decod- ing quality. The re\ufb01nement block enhances the result of the encoder block by performing 3 \u00d73 depthwise separable convolution followed by batch normalization and a ReLU6",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S37",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "non-linearity. We remove the re\ufb01nement block and study its impact on the \ufb01nal result. Enhancement Block The enhancement blocks are in- tended to give the network a layer to improve the \ufb01nal result before its resolutions are fully recovered. We study the ef- fect of the enhancement block by removing it entirely from the network. Table 4 illustrates the results when different components of the model architecture are modi\ufb01ed. We see that all the components contribute to the \ufb01nal performance of the pro- posed model. When the dilation rate is \ufb01xed to one, the",
      "page_hint": null,
      "token_count": 94,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S38",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "(\u00d710\u22123) No dilation 3.25 No enhancement in decoding 3.04 No re\ufb01nement in skip connection 3.07 Proposed model 2.93 Table 4. Ablation study on the test split of matting dataset. All",
      "page_hint": null,
      "token_count": 30,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S39",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "1.0. network has a hard time generalizing due to its limited ef- fective receptive \ufb01eld. Enhancement and re\ufb01nement in the decoding phase also boost the network performance. 4.4. Quantization We demonstrate the full pipeline for training a real-time portrait matting model targeting a mobile platform by incor- porating quantization of our model. Quantization of model parameters and its activation reduces the bit-width required by the model. The reduction of bit-width allows one to ex- ploit integer arithmetics in boosting the network inference speed. The target model undergoes a quantization-aware train- ing phase via fake quantization [17]. While maintaining full precision weights, tensors are downcasted to fewer bits during the forward pass. On a backward pass, the full pre- cision weights",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S40",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "are updated instead of downcasted tensors from which the gradients are computed. Once the training is complete, quantized models are executed using the Ten- sorFlow Lite framework [2]. Table 3 contains the result of 8-bit quantized model. The model enjoys 25% decrease in latency and better gradient error. The details for quantization are included in the sup- plementary material. 5. Related Work Image matting task has been mostly approached using sampling [12, 13, 15, 27, 34] or propagation-based [8, 14, 19, 30] ideas. Recently, with the success of convolutional neural networks (CNN) in computer vision tasks, there has been a growing number of works utilizing CNNs. Cho et al. [10] proposed end-to-end network which relies on other matting algorithms\u2019 outputs,",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S41",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "such as the closed form mat- ting [19] and the KNN matting [8], to produce the \ufb01nal al- pha matte. Shen et al. [29] proposed an automatic image matting method leveraging CNN to create a trimap which is fed to closed form matting [19] by backpropagating the matting error back to the trimap network. Xu et al. [36] take the approach further by directly learning the alpha matte. Chen et al. [9] combine trimap generation and alpha matte generation using a fusion module. Many works on image matting are mainly focused on achieving higher accuracy rather than the real-time infer- ence of models. But recently, researchers are shifting the fo- cus to networks that accommodate real-time inference [39]. Zhu et",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S42",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "al. [39] studied real-time portrait matting on mobile devices which is directly comparable to our result. Since the work of Long et al. [20], fully convolutional networks (FCN) have been widely used in various segmen- tation tasks [18, 37]. Many of the semantic segmentation networks adopt encoder-decoder structure [4]. The pro- posed model uses skip connections to concatenate the out- put of an encoder block to a decoder block which has been known to improve the result of semantic pixel-wise segmen- tation tasks [24]. Chen et al. [6] proposed DeepLab [5, 7] architecture which extensively uses the ASPP module. ASPP module aims to solve the problem of ef\ufb01cient upsampling and han- dling objects at multiple scales. Our model adopts a",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S43",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "multi- branch structure from Inception network [31], together with the dilated convolution of different dilation rates, which re- sembles the ASPP module. One of the most prominent light-weight neural networks is MobileNet and its variants [16, 26]. Depthwise separable convolution was shown to be extremely effective in creating a light-weight network while keeping the accuracy drop to a tolerable level. ENet, an ef\ufb01cient neural network architecture designed with the intention of tackling a semantic segmentation task, was proposed by Paszke et al. [21]. Our work is inspired by the design choices detailed in their work for creating an ef\ufb01cient neural network. 6. Conclusions In this work, we have proposed an ef\ufb01cient model for performing automatic portrait matting task on mobile",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S44",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "de- vices. We were able to accelerate the model four times to achieve 30 FPS on Xiaomi Mi 5 device with only 15% increase in the gradient error. Comparison against Mobile DeepLabv3 showed that our model is not only faster when the performance is comparable, but also requires an order of magnitude less number of parameters. Through abla- tion studies, we have shown that our choice of the multi- branch dilated convolution with a linear bottleneck is es- sential in maintaining high performance. We also make our implementation available at https://github.com/ hyperconnect/MMNet. A general extension of our work is to handle general im- age matting problem, such as automatic saliency matting. Since we can already achieve real-time, it is natural",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S45",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "to ex- tend the work further by tackling the video matting problem as well. Pushing for real-time inference on mobile devices requires a carefully prepared pipeline for it to work in a real-world setting. Distillation to guide the mobile-friendly model in training and even lower-bit quantization for added speedup is highly desired. References [1] OpenCV. https://opencv.org/. Accessed: 2018-10- 23. [2] TensorFlow Lite. https://www.tensorflow.org/ lite/. Accessed: 2018-10-23. [3] M. Abadi, P. Barham, J. Chen, Z. Chen, A. Davis, J. Dean, M. Devin, S. Ghemawat, G. Irving, M. Isard, et al. Tensor- \ufb02ow: A system for large-scale machine learning. In Pro- ceedings of the USENIX Symposium on Operating Systems Design and Implementation, 2016. [4] V . Badrinarayanan, A. Kendall, and R. Cipolla.",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S46",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "SegNet: A deep convolutional encoder-decoder architecture for image segmentation. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2017. [5] L.-C. Chen, G. Papandreou, F. Schroff, and H. Adam. Re- thinking atrous convolution for semantic image segmenta- tion. arXiv preprint arXiv:1706.05587, 2017. [6] L.-C. Chen, G. Papandreou, I. Kokkinos, K. Murphy, and A. L. Yuille. DeepLab: Semantic image segmentation with deep convolutional nets, atrous convolution, and fully con- nected CRFs. IEEE Transactions on Pattern Analysis and Machine Intelligence, 40(4):834\u2013848, 2018. [7] L.-C. Chen, Y . Zhu, G. Papandreou, F. Schroff, and H. Adam. Encoder-decoder with atrous separable convolution for se- mantic image segmentation. In Proceedings of the European Conference on Computer Vision, 2018. [8] Q. Chen, D. Li, and C.-K. Tang.",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S47",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "Knn matting. IEEE Trans- actions on Pattern Analysis and Machine Intelligence, 35(9): 2175\u20132188, Sept 2013. [9] Q. Chen, T. Ge, Y . Xu, Z. Zhang, X. Yang, and K. Gai. Se- mantic human matting. In Proceedings of the ACM Multime- dia Conference, pages 618\u2013626, 2018. [10] D. Cho, Y .-W. Tai, and I. Kweon. Natural image matting using deep convolutional neural networks. InProceedings of the European Conference on Computer Vision, 2016. [11] F. Chollet. Xception: Deep learning with depthwise separa- ble convolutions. arXiv preprint, pages 1610\u201302357, 2017. [12] Y .-Y . Chuang, B. Curless, D. H. Salesin, and R. Szeliski. A bayesian approach to digital matting. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recogni- tion, 2001.",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S48",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "[13] E. S. L. Gastal and M. M. Oliveira. Shared sampling for real-time alpha matting. Computer Graphics Forum, 29(2): 575\u2013584, May 2010. Proceedings of Eurographics. [14] L. Grady, T. Schiwietz, S. Aharon, and R. Westermann. Ran- dom walks for interactive alpha-matting. In Proceedings of Visualization, Imaging, and Image Processing, 2005. [15] K. He, C. Rhemann, C. Rother, X. Tang, and J. Sun. [16] A. G. Howard, M. Zhu, B. Chen, D. Kalenichenko, W. Wang, T. Weyand, M. Andreetto, and H. Adam. MobileNets: Ef\ufb01- cient convolutional neural networks for mobile vision appli- cations. arXiv preprint arXiv:1704.04861, 2017. [17] B. Jacob, S. Kligys, B. Chen, M. Zhu, M. Tang, A. Howard, H. Adam, and D. Kalenichenko. Quantization and training of neural networks",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S49",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "for ef\ufb01cient integer-arithmetic-only infer- ence. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2018. [18] S. J \u00b4egou, M. Drozdzal, D. Vazquez, A. Romero, and Y . Ben- gio. The one hundred layers tiramisu: Fully convolutional DenseNets for semantic segmentation. In IEEE Conference on Computer Vision and Pattern Recognition Workshops, 2017. [19] A. Levin, D. Lischinski, and Y . Weiss. A closed-form solu- tion to natural image matting. IEEE Transactions on Pattern Analysis and Machine Intelligence, 30(2):228\u2013242, 2008. [20] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional networks for semantic segmentation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recogni- tion, 2015. [21] A. Paszke, A. Chaurasia, S. Kim, and E. Culurciello.",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S50",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "Enet: A deep neural network architecture for real-time semantic segmentation. arXiv preprint arXiv:1606.02147, 2016. [22] P. O. Pinheiro, T.-Y . Lin, R. Collobert, and P. Dollar. Learn- ing to re\ufb01ne object segments. In Proceedings of the Euro- pean Conference on Computer Vision, 2016. [23] C. Rhemann, C. Rother, J. Wang, M. Gelautz, P. Kohli, and P. Rott. A perceptually motivated online benchmark for im- age matting. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2009. [24] O. Ronneberger, P. Fischer, and T. Brox. U-Net: Convolu- tional networks for biomedical image segmentation. In Pro- ceedings of the International Conference on Medical Image Computing and Computer Assisted Intervention, 2015. [25] C. Rother, V . Kolmogorov, and A. Blake.",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S51",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "\u201dGrabCut\u201d: Inter- active foreground extraction using iterated graph cuts. ACM Transactions on Graphics, 23(3):309\u2013314, August 2004. [26] M. Sandler, A. Howard, M. Zhu, A. Zhmoginov, and L.-C. Chen. MobileNetV2: Inverted residuals and linear bottle- necks. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2018. [27] E. Shahrian, D. Rajan, B. Price, and S. Cohen. Improving image matting using comprehensive sampling sets. In Pro- ceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2013. [28] X. Shen, A. Hertzmann, J. Jia, S. Paris, B. Price, E. Shecht- man, and I. Sachs. Automatic portrait segmentation for im- age stylization. In Computer Graphics Forum, volume 35, pages 93\u2013102, 2016. [29] X. Shen, X. Tao, H. Gao, C.",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S52",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "Zhou, and J. Jia. Deep automatic portrait matting. In Proceedings of the European Conference on Computer Vision, 2016. [30] J. Sun, J. Jia, C.-K. Tang, and H.-Y . Shum. Poisson matting. In ACM Transactions on Graphics, volume 23, pages 315\u2013 321, 2004. [31] C. Szegedy, W. Liu, Y . Jia, P. Sermanet, S. Reed, D. Anguelov, D. Erhan, V . Vanhoucke, and A. Rabinovich. Going deeper with convolutions. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2015. [32] C. Szegedy, V . Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna. Rethinking the inception architecture for computer vision. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 2818\u20132826, 2016. [33] M. Treml, J.",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S53",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "Arjona-Medina, T. Unterthiner, R. Durgesh, F. Friedmann, P. Schuberth, A. Mayr, M. Heusel, M. Hof- marcher, M. Widrich, B. Nessler, and S. Hochreiter. Speed- ing up semantic segmentation for autonomous driving. In Advances in Neural Information Processing Systems, 2016. [34] J. Wang and M. F. Cohen. Optimized color sampling for robust matting. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2007. [35] M. Wang, B. Liu, and H. Foroosh. Factorized convolutional neural networks. In ICCV Workshops, pages 545\u2013553, 2017. [36] N. Xu, B. L. Price, S. Cohen, and T. S. Huang. Deep image matting. In Proceedings of the IEEE Conference on Com- puter Vision and Pattern Recognition, 2017. [37] S. Zheng, S. Jayasumana, B. Romera-Paredes, V",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S54",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": ". Vineet, Z. Su, D. Du, C. Huang, and P. H. Torr. Conditional ran- dom \ufb01elds as recurrent neural networks. In Proceedings of the International Conference on Computer Vision, 2015. [38] S. Zheng, S. Jayasumana, B. Romera-Paredes, V . Vineet, Z. Su, D. Du, C. Huang, and P. H. S. Torr. Conditional ran- dom \ufb01elds as recurrent neural networks. In Proceedings of the International Conference on Computer Vision, 2015. [39] B. Zhu, Y . Chen, J. Wang, S. Liu, B. Zhang, and M. Tang. Fast deep matting for portrait animation on mobile phone. In Proceedings of the ACM Multimedia Conference, 2017. Supplemental Materials A. Quantization We used tensorflow.contrib.quantize to quantize our model. Custom implementation of resize_bilinear operation, optimized using SIMD",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S55",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "instructions was deployed. Since we are using fake quantization [17] for quantization-aware training, ad- ditional fake quantization node was inserted after a resize_bilinear operation. The quantized version of softmax provided by Tensor- Flow Lite is slow for our use case since it is optimized for a classi\ufb01cation task. Our formulation allows us the make an assumption that the output has only two channels. Quan- tizing the values to 8-bits means that there are only 65,536 valid logit pairs. Instead of explicit computation of soft- max, we precompute the values and substitute the calcula- tion with a table lookup. B. Latency Table 5 depicts the latency of different models measured on Pixel 1, Xiaomi Mi 5, and iPhone 8. All measure-",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S56",
      "paper_id": "arxiv:1904.03816v1",
      "section": "experiments",
      "text": "ments are performed with the TensorFlow Lite [2] bench- mark tool on a mobile device while restricting the models to use a single thread. The mean and the standard devia- tion obtained from 100 runs are included in the table. The measurements were separated apart in time to give the de- vice enough time to cool down. Demo video is available at https://github.com/hyperconnect/MMNet.",
      "page_hint": null,
      "token_count": 63,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S57",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "MD16-0.75 142 \u00b12 146 \u00b11 32 \u00b10 MMNet-1.00 127 \u00b11 129 \u00b11 30 \u00b10 MD8-0.75\u2217 111 \u00b11 113 \u00b11 22 \u00b10 MMNet-0.75 87 \u00b11 90 \u00b11 22 \u00b10 MD16-0.50 80 \u00b11 82 \u00b11 19 \u00b10 MD8-0.50\u2217 66 \u00b11 66 \u00b11 13 \u00b10 MMNet-0.50 60 \u00b10 61 \u00b11 15 \u00b10 MMNet-1.40\u2217 53 \u00b11 55 \u00b11 12 \u00b10 MD16-1.00\u2217 53 \u00b11 53 \u00b11 12 \u00b10 MD8-0.35\u2217 45 \u00b11 44 \u00b10 9 \u00b10 MD16-0.75\u2217 38 \u00b11 38 \u00b11 8 \u00b10 MMNet-1.00\u2217 33 \u00b11 32 \u00b11 8 \u00b10 MD16-0.75 104 \u00b11 - - MMNet-1.00Q 98 \u00b12 98 \u00b11 - Table 5. Latency of models on different mobile devices. All num- bers are in milliseconds. The row marked with\u2217displays the result using 128 inputs. Quantized",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S58",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "model is included in the last row. C. Detailed Architectures Table 6 illustrates the number of channels used in each component of MMNet. The initial block outputs a 32 chan- nel feature map, as described in the \ufb01rst row. The numbers in the encoder/enhancement columns represent the number of channels returned by the multi-branch 1 \u00d71 convolu- tions and the \ufb01nal output of the encoder/enhancement block after the concatenation. For example, encoder #6 will re- ceive a 40 channel input which the 1 \u00d71 convolutions in multiple branches each expand to 64 channels. After the multi-branch, the outputs are concatenated and convoled by a 1 \u00d71 convolution which compresses the number of chan- nels back to 40. Whenever there is",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S59",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "a skip connection, the output of a decoder block is concatenated with the output of a re\ufb01nement block. Their respective number of channels are delineated in the decoder rows. The \ufb01nal block returns a two-channel output, each for foreground and background. Name Output channels of 1x1 convolution First Encoder/Enhancement Decoder Re\ufb01nement Final Initial Block 32 \u2212,\u2212 \u2212 \u2212 \u2212 Encoder 1 \u2212 16,16 \u2212 \u2212 \u2212 Encoder 2 \u2212 16,24 \u2212 \u2212 \u2212 Encoder 3 \u2212 24,24 \u2212 \u2212 \u2212 Encoder 4 \u2212 24,24 \u2212 \u2212 \u2212 Encoder 5 \u2212 32,40 \u2212 \u2212 \u2212 Encoder 6 \u2212 64,40 \u2212 \u2212 \u2212 Encoder 7 \u2212 64,40 \u2212 \u2212 \u2212 Encoder 8 \u2212 64,40 \u2212 \u2212 \u2212 Encoder 9 \u2212 80,80 \u2212",
      "page_hint": null,
      "token_count": 120,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    },
    {
      "snippet_id": "Parxiv_1904_03816v1:S60",
      "paper_id": "arxiv:1904.03816v1",
      "section": "method",
      "text": "\u2212 \u2212 Encoder 10 \u2212 120,80 \u2212 \u2212 \u2212 Decoder 1 \u2212 \u2212 64 64 \u2212 Decoder 2 \u2212 \u2212 40 40 \u2212 Enhancement 1 \u2212 40,40 \u2212 \u2212 \u2212 Enhancement 2 \u2212 40,40 \u2212 \u2212 \u2212 Decoder 3 \u2212 \u2212 16 \u2212 \u2212 Final Block \u2212 \u2212 \u2212 \u2212 2 Table 6. The number of channels in different components of the proposed network.",
      "page_hint": null,
      "token_count": 64,
      "paper_year": 2019,
      "paper_venue": "arXiv",
      "citation_count": 0,
      "extraction_quality_score": 0.94337584273084,
      "extraction_quality_band": "good",
      "extraction_source": "native"
    }
  ],
  "extraction_meta": {
    "extractor": "pypdf",
    "two_column_applied": false,
    "ocr_applied": false,
    "pages_total": 11,
    "empty_pages": 0,
    "empty_page_pct": 0.0,
    "page_stats": [
      {
        "page": 1,
        "chars": 3360,
        "empty": false
      },
      {
        "page": 2,
        "chars": 4454,
        "empty": false
      },
      {
        "page": 3,
        "chars": 4621,
        "empty": false
      },
      {
        "page": 4,
        "chars": 3954,
        "empty": false
      },
      {
        "page": 5,
        "chars": 4573,
        "empty": false
      },
      {
        "page": 6,
        "chars": 748,
        "empty": false
      },
      {
        "page": 7,
        "chars": 4082,
        "empty": false
      },
      {
        "page": 8,
        "chars": 5065,
        "empty": false
      },
      {
        "page": 9,
        "chars": 5946,
        "empty": false
      },
      {
        "page": 10,
        "chars": 4277,
        "empty": false
      },
      {
        "page": 11,
        "chars": 582,
        "empty": false
      }
    ],
    "quality_score": 0.9434,
    "quality_band": "good"
  }
}